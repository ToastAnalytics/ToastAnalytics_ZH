# 开始

该文档主要阐述了在安卓操作系统中导入Analytics SDK的方法。为了使用Analytics SDK，必须先注册APP。APP的注册方法，请参考此链接（http://docs.cloud.toast.com/ko/Analytics/App%20Analytics/Getting%20Started/#_4）。
**有关活动关联内容将另附文档。在本文中只讲述了如何体现客户端的内容。具体内容请参考“活动关联指南”。**


# 项目设置


## SDK下载

1. 下载Analytics SDK
在http://cloud.toast.com/documents/6/中下载Android SDK。
2. 下载Google Service API
若要在Analytics SDK中使用Advertising ID，需要有Google Player Service。
使用安卓SDK Manager，可以下载最新版本的Google Play Service API（google-play-service.jar）。
  (https://developer.android.com/sdk/installing/adding-packages.html)


## 项目设置

### 程式库相依(library dependency) 设置
如将已下载的GameAnalyticsSDK_Android_v1.xxx.zip文件解压，就会生成叫为ToastAnalyticsSDK的Android工作项目，将其工作项目添加到work space后进行相依设置即可。相依(dependency)设置，在用户工作项目root文件夹右点击后在 Properties > Android 项目的Library按Add键就可以添加，请在列表中选择ToastAnalyticsSDK即可。

已下载的Google服务的API的话，不是jar形式而是安卓程式库(library)库存，只有将程式库(library)使用eclipse输入才能在用户工作项目上使用。
(http://developer.android.com/google/play-services/setup.html)

利用eclipse将Google服务API输入到程式库后，如上添加ToastAnalyticsSDK时，在Properties > Android > Library按Add键后选择google-play-services即可。

### 隐藏文件夹依赖关系设置(Android Studio)

如您解除已下载的GameAnalyticsSDK_Android_v1.xxx.zip文件，即将出现名为ToastAnalyticsSDK的安卓工作计划，然后将此计划添加至模块后金斯能够依赖关系设置即可。

在Android Studio生成工作程序后，接着选择 File - New - Import Module 菜单。

![Import Module Step1](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_003.png)

选择解压的 ToastAnalyticsSDK Android 工作计划路径。

![Import Module Step2](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_004.png)

选择合理的选项后进行下一步。通常使用默认值。

![Import Module Step3](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_005.png)

应先添加模块后进行依赖管理设置。请先在File菜单选中Project Structure。

![Project Setting 1](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_006.png)

因为您已将ToastAnalyticsSDK添加为Module，而要选择模块依赖关系（Module dependency）。

![Project Setting 2](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_007.png)

选择toastAnalyticsSDK添加依赖关系。

![Project Setting 3](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_008.png)

google play service隐藏文件夹也应添加依赖关系。如果google play service已被添加为工作计划的话，就可跳过此步骤。

![Project Setting 4](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_009.png)

google play service的版本按环境如何会不同。为适用Toast Analytics SDK，就需安装Google Play Services 7.5以上的版本。

![Project Setting 5](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_010.png)

可删除被包含为ToastAnalytics SDK隐藏文件夹的AndroidManifest.xml文件的“应用（Application）”要素。

### AndroidManifest设置
在Analytics SDK中使用如下权限（Permission）。

```xml
<!– 为查询终端机调制解调器（Moderm）状态（ex. 网络运营商名称）而用。-->
<uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
<uses-permission android:name="android.permission.INTERNET" />
```

商铺信息提供为追踪用户下载应用的商铺信息。当前可使用的商铺如下。
(如使用未定义的商铺值，就会被分类为“其他”。若您需要添加商铺，请与管理者联系。)

商铺 | 输入字符串 (android:value=)
------------- | -------------
Google Play Store | Google
Apple App Store | Apple
Naver Store | Naver
T-Store | Tstore
One Store | onestore
China AOS-360 | CN_360
China AOS-Baidu | CN_Baidu
China AOS-Xiaomi | CN_Xiaomi
China AOS-UC | CN_UC
China AOS-Bilibili | CN_Bilibili
China AOS-Flyme | CN_Flyme
China AOS-37 | CN_37
China AOS-Otaku | CN_Otaku
China AOS-OPPO | CN_Oppo
China AOS-HUAWEI | CN_Huawei
China AOS-ANZHI | CN_Anzhi
China AOS-WANDOU | CN_Wandou
China AOS-OtakuChannel | CN_OtakuChannel
China AOS-Tencent | CN_Tencent
China AOS-Lenovo | CN_Lenovo
China AOS-Site (直接分发（*不通过商铺）) | CN_Direct

```xml
<manifest>
    ……
    <application>
        ……
        <!-- 应用商店信息设置 -->
        <!-- android:value is Tstore, Olleh, Uplus, NaverApp etc  -->
        <meta-data
            android:name="com.toast.android.analytics.appstore"
            android:value="Google" />
        ……
    </application>
</manifest>
```
    

若想分析安装下载的路径，需要进行Install Receiver的设置。（只有通过Google Play下载APP时，才可以启动。）

```xml
<manifest>
    ……
    <application>
        ……
        <receiver
            android:name="com.toast.android.analytics.InstallReferrerReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="com.android.vending.INSTALL_REFERRER"/>
            </intent-filter>
        </receiver>
        ……
    </application>
</manifest>
```

    
同步处理行为的广播接收器（Broadcast Receiver），在APP里只能注册一个。在多处使用Install Referrer时，必须按照如下指南进行设置。

只注册一个广播接收器后，使用元数据（meta-data）再添加其他接收器即可。

如果在Install Receiver的设置上出现错误，将导致新用户数统计的精准度降低。

若想添加其他接收器，使用元数据按照如下设置步骤进行添加即可，这时在android:value中应填入该接收器的级别（Class）。

```xml
<receiver 
    android:name="com.toast.android.analytics.InstallReferrerReceiver" 
    android:exported="true">
    <intent-filter>
        <action android:name="com.android.vending.INSTALL_REFERRER"/>
    </intent-filter>

    <meta-data android:name="forward1" android:value="Receiver-Class-Name" />
    <meta-data android:name="forward2" android:value=" Receiver-Class-Name" />
</receiver>
```


为了分析运行路径，需要进行Execution Receiver的设置。

这里所说的接收器是指在安装APP的状态下，若发生通过推广运行APP的情况时，为了进行效果分析而使用的接收器，
且需要与Install Receiver一同注册。

```xml
<manifest>
  ……
  <application>
    ……
      
      <receiver android:name="com.toast.android.analytics.ExecutionReferrerReceiver" android:exported="true">
        <intent-filter>
          <action android:name="com.toast.android.analytics.toastpromotion.EXECUTION" />
        </intent-filter>
      </receiver>
        ……        
    <application>
</manifest>
```

 
# 必须关联的接口

为了收集基本的统计数据，必须要关联的API接口。只要创建好必须关联的项目，也可以查看大部分的数据。
必须关联的项目如下：

* 初始化 : initializeSDK
* 会话跟踪 : traceActivation, traceDeactivation
* 购买 (In App Purchase) : tracePurchase
* 获得/使用虚拟货币 : traceMoneyAcquisition, traceMoneyConsumption
* 升级 : traceLevelUp
* 好友数 : traceFriendCount


## 初始化

为了使用SDK，需要有注册APP之后发放的“APP账号”和“企业账号”。注册APP的方法，请参考此链接（http://docs.cloud.toast.com/ko/Analytics/App%20Analytics/Getting%20Started/#_4）。

initializeSDK函数中的AppID将使用APP信息中的“App密钥”，而CompanyID则使用“企业账号”。

![图4 认证密钥信息](images/pg_unity_004.png)

若想使用GameAnalytics SDK，必须先进行SDK的初始化。

GameAnalytics类initializeSDK函数是指进行SDK初始化的函数，该函数主要进行内部所需数据（设备信息、APP设置信息）的确认和传送日志所需环境的设置。

```java
import com.nhnent.android.toast.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, false);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }

  }
```
    
## 设定区分用户的基准

** 在运营过程中若变更区分用户的基准，将会断开变更前/后数据的关联关系，因此在游戏上线之后，尽量不要变更此基准。 **

Analytics作为区分用户的基准，将使用Advertise ID或User ID，但是这两个ID不允许同时使用，而是根据游戏政策，需要做出二者选一。

一般情况下，都是以Advertise ID作为使用基准的，但是如果在游戏里有特殊要求，也可以把User ID作为使用基准。

例如，使用Advertise ID在同一台设备中进行账号关闭->重新加入时，被视为同一用户；相反，如果使用User ID，则被视为新注册用户。

或者一名用户在使用两部设备的情况下，如果使用Advertise ID，将被视为不同用户；相反，如果使用User ID，则被视为一名用户。

因为涉及到这一部分内容，所以在游戏中需要先确定好使用基准。

可以将初始化函数（initializeSDK）的最后因子（use logging userid flag）设为该值。当Flag值为true时，将UserID作为区分用户的使用基准；如果设为False，则把Advertise ID作为区分用户的使用基准。

下面代码就是将User ID作为区分用户使用基准的情况。

```java
import com.nhnent.android.toast.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }
    ……
    // 在游戏里完成登录处理
    ……
    // 把User ID作为区分用户的基准时，注册User ID的函数。
    GameAnalytics.setUserId(“user_id”, true);
    ……
}
```
    
将初始化函数的最后因子（use logging userid flag）设为true时，必须要先调用setUserId后，再注册UserID。把Flag值设为true之后，如果不调用setUserId，会致使以后调用的所有API以失败（E_LOGGING_USER_ID_EMPTY）返回。

使用推广或活动的情况下，setUserId的第二个因子就是true，否则就是false。

当调用完initializeSDK之后，因成功登录游戏而获得了可在游戏中使用的userID后，方可调用setUserId函数。userID可以使用在游戏中用以区分用户的值。

有关Advertise ID的内容，请参考以下链接。
- Android : https://developer.android.com/google/play-services/id.html


## 会话跟踪

为了跟踪DAU(Daily Active User)和游戏滞留时间而关联的项目。

开始/结束App、移到后台（Background）/前台（Foreground）时，可以调用并测量与该动作相符的API。 

初次运行App（initializeSDK之后）或从后台（background）移到前台（foreground）时，通过调用traceActivation来进行会话跟踪，然后待App进入到后台时，再调用traceDeactivation来停止会话跟踪。

如果调用traceDeactivation，就可以计算出traceActivation和traceDeactivation之间的时间，以此来测定游戏时间，并且SDK内部运行的程序，也将在traceDeactivation命令中被中止。 

移到后台/前台时，如果不调用上述函数，就无法测出准确的游戏时间，因此必须要调用此API。

DAU通常去除一日之内重复调用traceActivation的用户数（以Advertise ID或User ID为基准）后进行统计。

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onResume()
  {
    // 通知服务器已切换到前台状态
    GameAnalytics.traceActivation(this);
  }

  @Override
  protected void onPause()
  {
    // 通知服务器已切换到后台状态
    GameAnalytics.traceDeactivation(this);
  }
}
```


## 行为跟踪

可以跟踪用户对In-App Purchase、获得/使用虚拟货币、升级和好友数变更等行为。

### In-App Purchase

发生In-App Purchase之后，才能调用tracePurchase来传送购买信息。

Currency将使用在ISO-4217(http://en.wikipedia.org/wiki/ISO_4217)中自定义的代码。

例如，购买$0.99钻石时，将按如下步骤进行操作：

（这里的“GEM_10”是指游戏中自定义的道具代码，而Unit Cost是指该道具的单位价格，Payment是指用户实际发生的费用，Level应输入已购买用户的级别。）

```java
GameAnalytics.tracePurchase("GEM_10", 0.99f, 0.99f, "USD", 10);
```


### 虚拟货币的获得和使用

在游戏中获得并使用虚拟货币时，才可以调用此选项，且可以跟踪一次和二次虚拟货币数量的变化。一般来说，一次虚拟货币是指通过In-App Purchase购买的虚拟货币（ex.钻石、红钻等）；二次虚拟货币是指使用一次虚拟货币购买的虚拟货币（ex.樱桃、爱心等）。

通过IAP购买10颗钻石时，将按如下步骤进行操作： 

（“CODE_IAP”是指游戏中自定义的代码。如一次虚拟货币时，Type为0，而二次虚拟货币是1）

```java
GameAnalytics.traceMoneyAcquisition("CODE_IAP", "0", 10, 10);
```

使用10颗钻石购买100个樱桃时，将按如下步骤进行操作：

```java
// 使用一次虚拟货币
GameAnalytics.traceMoneyConsumption("CODE_USE_GEM", "0", 10, 10);

// 2 获得二次虚拟货币
GameAnalytics.traceMoneyAcquisition("CODE_BUY_CHERRY", "1", 100, 10);
```

使用一次虚拟货币购买二次虚拟货币时，将会出现‘一次虚拟货币减少’->‘二次虚拟货币增加’的情况。但是为了购买二次货币而使用一次虚拟货币时，如果不想判定为是额外支付，也可以单传送‘获得二次虚拟货币’的日志（log）。

### 升级

用户级别出现变更时，将调用traceLevelUp。需要注意的是大部分的行为跟踪API，为了跟踪到各级别的行为，需要同时接收用户的级别。 

当用户级别变为10时，将按如下步骤进行调用，这时该用户的级别必须要提升，若降低，则无法测出准确的数据。

例如，像《糖果传奇》（Candy Crush Sage）一样用关卡表示级别的游戏中，只需要在最初进入该关卡时保留升级Log即可，如果返回到以前关卡进行游戏时，则无需保留升级log。

并且向其他API传送的级别值也应该使用用户的最高关卡值，而不是当前进行的关卡值。

```java
GameAnalytics.traceLevelUp(10);
```


### 好友

表示注册用户的好友数。通常运行APP之后，待好友信息加载完成时，即可调用。

```java
GameAnalytics.traceFriendCount(100);
```


# 选择关联的接口

本内容主要讲述在游戏中除了通过基本接口所提供的基本指标以外，还有追加测量的指标和在Analytics应用中所提供的活动功能的使用方法。

追加关联的项目如下：

* 活动（Campaign）连接 : setCampaignListener, (show/hide)Campaign
* 收集自定义事件（Custom Event） : traceEvent
* 测量所需时间 : traceStartSpeed, traceEndSpeed


## 活动（Campaign）关联

### 事先做好活动关联的准备
有关活动关联及执行内容，将另附指南。
请参考Toast Analytics中“活动执行”菜单里的“页面指南” 。
http://analytics.toast.com/promotion/share/document/4.2_Campaign_run.pdf

### 联动推送

为在Analytics SDK使用推送进行宣传活动，应使用 Toast Cloud Push。
关于使用推送的详细内容，请参考 Toast Cloud Push提供的 “Client SDK Guide”。

http://docs.cloud.toast.com/ko/Notification/Push/Client%20SDK%20Guide/

为使用推送，除AndroidManifest.xml文件外，还要注册Toast Cloud Push SDK提供的 custom reciever。

```xml 
<manifest>
  ……
  <application>
    ……
    <!-- 使用GCM时 -->
    <service android:name="com.toast.android.analytics.receiver.GcmBroadcastReceiver" android:exported="false">
            <intent-filter>
                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
            </intent-filter>
    </service>
    
    <!-- 使用Tencent时 -->
    <receiver android:name="com.toast.android.analytics.receiver.TencentBroadcastReceiver">
        <intent-filter>
            <action android:name="com.tencent.android.tpush.action.PUSH_MESSAGE" />
            <action android:name="com.tencent.android.tpush.action.FEEDBACK" />
        </intent-filter>
    </receiver>
    …… 
    </application>
</manifest>
```

如从服务器收到推送(GCM)信息，Analytics SDK向Notification Bar显示提醒。
触摸此提醒，即将启动应用。此时，若不进行任何设置，即将显示Main Activity。

如欲启动不是Main Activity的其他Activity，应通过 “setPushIntent”变量明示地指定。

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    Intent intent = new Intent(getApplicationContext(), GCMActivity.class);
    GameAnalytics.setPushIntent(intent);
    ……
} 
```

此外，若把在AndroidManifest.xml的Activity的launchMode设置为 singeTop, singleTask, singleInstance时，就不制作新Activity而使用原有的。

此时，为正确地收到包含推送资料的Intent信息，就应在相应Activity明示覆盖 “onNewIntent”。

```java
public class TestActivity extends Activity {
    
  @Override
  protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    setIntent(intent);
  }
}
```

接着，把在Toast Cloud Push SDK提供的register函数设置为变量因素的用户ID资料设置为 GameAnalytics.tracePushUserId变量后进行呼叫。
此用户ID资料可能会与在GameAnalytics.setUserId设置的用户ID不同，应相同与使用为register变量的用户ID。 
关于register变量的详细内容，请参考 Toast Cloud Push提供的 “Client SDK Guide”。

http://docs.cloud.toast.com/ko/Notification/Push/Client%20SDK%20Guide/

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    // Toast Push SDK 
    int error = PushSdk.register(APP_KEY, UID, new PushSdk.OnRegister() {
        @Override
        public void fire(int error) {
            if (error == 0) {
                // 注册完后将UID呼叫为因素
                GameAnalytics.tracePushUserId(UID); 
            } 
        }
    }
……
```

### 活动监听器（ Listener ）的创建及注册

SDK定期与活动服务器连接后，将获取与活动及奖励相关的信息。如果当前用户有要进行的活动或获得的奖励信息时，将通过活动监听器（Listener）发送通知。

另外，为了获得活动信息，需要创建活动监听器（Listener）。

```java
public interface CampaignListener {
    void onCampaignVisibilityChanged(string adspaceName, bool show);
    void onCampaignLoadSuccess(string adspaceName);
    void onCampaignLoadFail(string adspaceName, int errorCode, string errorMessage);
    void onMissionComplete( missionList);
    void onCampaignClick(string callbackInfo);
    void onPromotionVisibilityChanged(bool show)
}
```


出现如下情况时，可以调用下列回调函数（Callback）：

* onCampaignVisibilityChanged：调用showCampaign、hideCampaign之后，当出现或消失与活动相关的弹窗和横幅时，就会被调用。
* onMissionComplete：用户进行活动/推广（Promotion）的同时，完成了指定任务而需要发送奖励信息时，就会被调用，并借助在此获得的信息，通过游戏服务器向用户发放奖励。与活动奖励相关的进程，请参考“活动应用指南”。
* onCampaignLoadSuccess, OnCampaignLoadFail：它将通知在服务器中获取到的活动信息的Parsing结果。在游戏里无需特殊处理该回调函数（Callback），它只是为了确认log而提供的回调函数罢了。
* onCampaignClick : 是链接选项选择Deeplink的话，即为传递登录字符串的CALLBACK。 参考所接收的字符串在游戏中对所希望进行的动作进行处理。
* onPromotionVisibilityChanged：在使用推广的情况下，当开启或关闭推广视图（Promotion View）时，就会被调用。

创建的活动监听器，将通过setCampaignListener进行注册。


```java
public void setListener {
  ……
  GameAnalytics.setCampaignListener(new MyCampaignListener() {
    public void onCampaignVisibilityChanged(string adspaceName, bool show) {
      ……
    }

    public void onCampaignLoadSuccess(string adspaceName) {
      // for Debugging
    }

    public void onCampaignLoadFail(string adspaceName, int errorCode, string errorMessage) {
      // for Debugging
    }

    public void onMissionComplete(List<string> missionList) {
      // 在missionList String中，key/value的信息将以分割符‘|’显示。
      // 通过游戏服务器在推广服务器（promotion server）中验证其值后，向用户
      // 发放奖励。
    }
    
    public void onCampaignClick(string callbackInfo) {
      // 是链接选项选择Deeplink的话，即为传递登录字符串的CALLBACK。 
      // 参考所接收的字符串在游戏中对所希望进行的动作进行处理。
    }
    
    public void onPromotionVisibilityChanged(bool show) {
      // 当推广视图被开启时，show将转为true。
      // 将show设为true时，可以降低游戏渲染（Rendering）的功能。
      // 相反，show设为false时，可以使游戏渲染功能恢复至原来的状态。
    }
  });
}
```

### 活动的展示（Show）/隐藏（Hide）
是指当前用户若有正在进行的活动时，向该用户展示在Analytics网站注册的活动弹窗/横幅的同时，将已展示的弹窗/横幅隐藏的一种方法（Method）。参数adspaceName，可以使用在Analytics网站注册时使用的adspace名称。这里的Adspace是指游戏内展示弹窗/横幅的特定位置。

如果活动中不使用该adspace，showCampaign() Method将不会启动，所以先确定好游戏内可出现活动弹窗/横幅的几个地点后，以不同的adspaceName调用函数的话，可以不经过游戏客户端的修改，游戏运营人员也可以通过在Analytics网站自行注册活动这一步骤，将弹窗/横幅展示给用户。注册Adspace的方法，请参考“活动测试指南”。

```java
public static int showCampaign(String adspaceName, Activity activity)
public static int showCampaign(String adspaceName, Activity activity, int animation, int lifeTime) 
public static int hideCampaign(String adspaceName)
public static int hideCampaign(String adspaceName, int animation)
```

## 自定义事件（Custom Event）的使用

需要给各游戏进行定义和分析特定事件时使用。

例如，使用Fever Time Item时，将按如下步骤进行操作。使用的所有代码，在游戏中自定义后使用。下面示例是在特定关卡中，为了跟踪道具变动内容而自定义的代码。

```java
GameAnalytics.traceEvent("ITEM", "ITEM_USE", "FEVER", "STAGE_10", 1, 10);
```

也可以在特定级别中跟踪与BOSS对战的结果时使用。

```java
GameAnalytics.traceEvent("STAGE", "STAGE_BOSS_VICTORY", "DRAGON_VALLEY", "BOSS_MOB", 1, 10);
```

除此之外，还具有可跟踪游戏内特殊事件的多种用途。

在traceEvent中使用的String Type参数（event type, event code, param1, param2），每个最多可用50字节，而且在event下面有可能发生的param1最多为300个，在param1下面有可能发生的param2最多为200个。

Event Code必须要唯一。虽Event Type但Event code同意的话，查询时指标将为Sum，请在显示时予以注意。

详细内容请参考Toast Analytics网站的指南。（点击Custom event页面右上角的“页面指南”，即可下载）


## 联动推广（Promotion）

在游戏内与其他游戏进行联动推广时使用。

### 事先做好联动推广的准备
有关联动及执行推广的内容，将另附指南。

### 添加推广按键
在Analytics设置页面中，如果注册完推广信息后，再注册按键图片（image），就可以在SDK初始化时，将下载的按键保存在设备（Device）中。

在游戏中需要使用按键图片在适当的位置生成按键。

生成按键之前，需要先确认一下是否可以进行推广。当管理者在Analytics网站中设置为不使用推广，或者出现按键图片下载失败或正在进行推广维护或故障时，就无法进行推广了，所以画面中不应该显示按键。通过“isPromotionAvailable()”可以确认到能否进行推广。如果可以进行推广，使用“getPromotionButtonImagePath()&rdqou; 函数确认按键图片的路径后，在游戏内适当的位置生成按键即可。（按键图片要以PNG形式保存。）

（如果不想使用在Analytics设置中注册的图片，那么可以使用包含在游戏发布包中的图片生成按键。但是，这时也需要先确认一下能否进行推广-isPromotionAvailable-，然后再生成按键。）

```java
if (GameAnalytics.isPromotionAvailable() == true) {
    String buttonImagePath = GameAnalytics.getPromotionButtonImagePath();
    Drawable d = new BitmapDrawable(activity.getResources(), buttonImagePath);
    ……
} else {
    Debug.Log ("Hide Toast Promotion Button");
}
```

### 推广执行
点击推广按键的同时调用“launchPromotionPage()”后，执行推广即可。

```java
private void touchPromotionButton() {
    ……
    GameAnalytics.launchPromotionPage();
    ……
}
```

“launchPromotionPage()”에서는 내부적으로 WebView를 사용하여 프로모션 컨텐츠를 제공합니다. 이 기능을 사용하기 위해서는 AndroidManifet.xml 설정에 해당 Activity를 추가해야 합니다.

使用android:screenOrientation设置横/竖屏的固定。 (http://developer.android.com/guide/topics/manifest/activity-element.html#screen)

```xml
<activity
    android:configChanges="keyboard|keyboardHidden|orientation|
        screenLayout|uiMode|screenSize|smallestScreenSize"
    android:name="com.toast.android.analytics.PromotionActivity" />
```

并且安装/运行APP时，为了测试其广告效果，需要先注册Install Receiver。

Install Receiver是指通过推广安装APP时（仅适用于Google Play），为了能够测出其效果所需要的程序；Execution Receiver是指在已安装APP的情况下，通过推广测试其执行效果时所需要的程序。详细内容请参照“2.2.2. AndroidManifest设置”。


### 奖励
向用户展示推广页面的同时，即发放奖励。并且通过推广安装APP或已完成指定任务时，也会发放奖励。

有关奖励信息，将通过“活动监听器”的“onMissionComplete”传送给用户。

奖励流程，请参考“应用及运营推广指南”。


## 测量所需时间

可以测量特定区间所需时间。例如，不管是测量新手教程还是转换场景（Scene）时所需的时间，只要是需要测量时间的任何区间，都可以使用它。

需要测量介绍场景（Intro Scene）的加载时间时，按如下步骤操作即可。“INTRO_LOADING”是指游戏内对特定的区间自定义的值。

```java
private void onStart() {
    GameAnalytics.traceStartSpeed("INTRO_LOADING");
}

private void onLoadCompleted() {
    GameAnalytics.traceEndSpeed("INTRO_LOADING");
}
```

## Facebook安装追踪

可追踪通过Facebook广告的应用安装。此功能将利用提供的
关系详细事宜及测试方法，请参考facebook提供的文件(https://developers.facebook.com/docs/app-ads/deep-linking)。
 ApplinkData.fetchDeferredAppLinkData是Facebook SDK所提供的API。
(https://developers.facebook.com/docs/reference/android/current/class/AppLinkData/)

```java 
AppLinkData.fetchDeferredAppLinkData(this,
    new AppLinkData.CompletionHandler() {
        @Override
            public void onDeferredAppLinkDataFetched(AppLinkData appLinkData) {
                if (appLinkData != null) {
                    GameAnalytics.traceFacebookInstall(context, String.valueOf(appLinkData.getTargetUri()));
                }
            }
        }
);}
```

# SDK设置

## DEBUG模式的激活
在开发过程中，为了确认SDK日志（log），可以设置日志的输出与否。

该函数在initializeSDK的之前/之后，都可以进行调用，基本值为setDebugMode(false)。

Log tags是以“Analytics:”开始的，如果在Eclipse中将logcat过滤器指定为“Analytics”，就可以确认在SDK发生的日志。

```java
private void Start () {
     ……
     GameAnalytics.setDebugMode(true);
     ……

     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", false);

     if (result != 0 ) {
        // SDK初始化失败
     }
     ……
}
```

激活DEBUG模式后，可以确认传送日志的内容。传送完日志后，再确认其回复就可确定日志是否传送无误。出现如下日志字符串，就说明收集到的数据已正常传送到了服务器上。（***是根据情况会出现不同的值）

```
Android : server response (***) : 200 OK
```


## 设备（Device）信息的确认
可以确认在SDK获取到的设备信息。

当前可以确认到设备账号、推送令牌和活动用户账号的值，这些都是测试活动连接时所需的值。详细内容请参考“活动连接指南”。

下面是为了确认设备信息而使用的密钥值。
- public static final String DEVICE_INFO_DEVICEID = “deviceId”;
- public static final String DEVICE_INFO_PUSH_USERID = “pushUserId”;
- public static final String DEVICE_INFO_CAMPAIGN_USERID = ”campaignUserId”;

```java
private void printDeviceInfo() {
     String deviceID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_DEVICEID);
     String pushToken = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_PUSH_USERID);
     String campaignUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_CAMPAIGN_USERID);
     ……
}
```

## SDK版本的确认
SDK版本可以通过 "GameAnalytics.getVersion()”函数进行确认。

```java
public static String getVersion()
```
