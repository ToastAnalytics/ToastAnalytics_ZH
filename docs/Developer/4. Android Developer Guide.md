# 开始

该文档主要阐述了在安卓操作系统中导入Analytics SDK的方法。为了使用Analytics SDK，必须先注册APP。APP的注册方法，请参考此链接（http://cloud.toast.com/documents/2/）。
**有关活动关联内容将另附文档。在本文中只讲述了如何体现客户端的内容。具体内容请参考“活动关联指南”。**


# 项目设置


## SDK下载

1. 下载Analytics SDK
在http://cloud.toast.com/documents/6/中下载Android SDK。
2. 下载Google Service API
若要在Analytics SDK中使用Advertising ID，需要有Google Player Service。
使用安卓SDK Manager，可以下载最新版本的Google Play Service API（google-play-service.jar）。
  (https://developer.android.com/sdk/installing/adding-packages.html)


## 项目设置

### 程式库相依(library dependency) 设置
如将已下载的GameAnalyticsSDK_Android_v1.xxx.zip文件解压，就会生成叫为ToastAnalyticsSDK的Android工作项目，将其工作项目添加到work space后进行相依设置即可。相依(dependency)设置，在用户工作项目root文件夹右点击后在 Properties > Android 项目的Library按Add键就可以添加，请在列表中选择ToastAnalyticsSDK即可。

(使用Proguard时，请添加以下项目. "-keep public class com.toast.android.analytics.external.leaktest.MemoryInfo { public *;}")

已下载的Google服务的API的话，不是jar形式而是安卓程式库(library)库存，只有将程式库(library)使用eclipse输入才能在用户工作项目上使用。
(http://developer.android.com/google/play-services/setup.html)

利用eclipse将Google服务API输入到程式库后，如上添加ToastAnalyticsSDK时，在Properties > Android > Library按Add键后选择google-play-services即可。


### AndroidManifest设置
在Analytics SDK中使用如下权限（Permission）。


```
<!– 为查询终端机调制解调器（Moderm）状态（ex. 网络运营商名称）而用。-->
<uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<!– 使用外部内存的权限，主要为未传送出去的内部使用的数据缓存而用。-->
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
<uses-permission android:name="android.permission.INTERNET" />
```


应用商店信息是专为跟踪用户安装下载的APP应用市场而设置的，可以根据“Google”、“Tstore”、“Naver”等市场的需求变更后使用。市场的字符串可以在游戏中任意定义后使用。

```
<manifest>
    ……
    <application>
        ……
        <!-- 应用商店信息设置 -->
        <!-- android:value is Tstore, Olleh, Uplus, NaverApp etc  -->
        <meta-data
            android:name="com.toast.android.analytics.appstore"
            android:value="Google" />
        ……
    </application>
</manifest>
```
    

若想分析安装下载的路径，需要进行Install Receiver的设置。（只有通过Google Play下载APP时，才可以启动。）

```
<manifest>
    ……
    <application>
        ……
        <receiver
            android:name="com.toast.android.analytics.InstallReferrerReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="com.android.vending.INSTALL_REFERRER"/>
            </intent-filter>
        </receiver>
        ……
    </application>
</manifest>
```

    
同步处理行为的广播接收器（Broadcast Receiver），在APP里只能注册一个。在多处使用Install Referrer时，必须按照如下指南进行设置。

只注册一个广播接收器后，使用元数据（meta-data）再添加其他接收器即可。

如果在Install Receiver的设置上出现错误，将导致新用户数统计的精准度降低。

若想添加其他接收器，使用元数据按照如下设置步骤进行添加即可，这时在android:value中应填入该接收器的级别（Class）。

```
<receiver 
    android:name="com.toast.android.analytics.InstallReferrerReceiver" 
    android:exported="true">
    <intent-filter>
        <action android:name="com.android.vending.INSTALL_REFERRER"/>
    </intent-filter>

    <meta-data android:name="forward1" android:value="Receiver-Class-Name" />
    <meta-data android:name="forward2" android:value=" Receiver-Class-Name" />
</receiver>
```


为了分析运行路径，需要进行Execution Receiver的设置。

这里所说的接收器是指在安装APP的状态下，若发生通过推广运行APP的情况时，为了进行效果分析而使用的接收器，
且需要与Install Receiver一同注册。

```
<manifest>
  ……
  <application>
    ……
      
      <receiver android:name="com.toast.android.analytics.ExecutionReferrerReceiver" android:exported="true">
        <intent-filter>
          <action android:name="com.toast.android.analytics.toastpromotion.EXECUTION" />
        </intent-filter>
      </receiver>
        ……        
    <application>
</manifest>
```

 
# 必须关联的接口

为了收集基本的统计数据，必须要关联的API接口。只要创建好必须关联的项目，也可以查看大部分的数据。
必须关联的项目如下：

* 初始化 : initializeSDK
* 会话跟踪 : traceActivation, traceDeactivation
* 购买 (In App Purchase) : tracePurchase
* 获得/使用虚拟货币 : traceMoneyAcquisition, traceMoneyConsumption
* 升级 : traceLevelUp
* 好友数 : traceFriendCount


## 初始化

为了使用SDK，需要有注册APP之后发放的“APP账号”和“企业账号”。注册APP的方法，请参考此链接（http://cloud.toast.com/documents/2/）。

initializeSDK函数中的AppID将使用APP信息中的“App密钥”，而CompanyID则使用“企业账号”。

![图4 认证密钥信息](images/pg_unity_004.png)

若想使用GameAnalytics SDK，必须先进行SDK的初始化。

GameAnalytics类initializeSDK函数是指进行SDK初始化的函数，该函数主要进行内部所需数据（设备信息、APP设置信息）的确认和传送日志所需环境的设置。

```
import com.nhnent.android.toast.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, false);

    if(result != GameAnalytics.S_SUCCESS)
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }

}
```
    
## 设定区分用户的基准

** 在运营过程中若变更区分用户的基准，将会断开变更前/后数据的关联关系，因此在游戏上线之后，尽量不要变更此基准。 **

Analytics作为区分用户的基准，将使用Advertise ID或User ID，但是这两个ID不允许同时使用，而是根据游戏政策，需要做出二者选一。

一般情况下，都是以Advertise ID作为使用基准的，但是如果在游戏里有特殊要求，也可以把User ID作为使用基准。

例如，使用Advertise ID在同一台设备中进行账号关闭->重新加入时，被视为同一用户；相反，如果使用User ID，则被视为新注册用户。

或者一名用户在使用两部设备的情况下，如果使用Advertise ID，将被视为不同用户；相反，如果使用User ID，则被视为一名用户。

因为涉及到这一部分内容，所以在游戏中需要先确定好使用基准。

可以将初始化函数（initializeSDK）的最后因子（use logging userid flag）设为该值。当Flag值为true时，将UserID作为区分用户的使用基准；如果设为False，则把Advertise ID作为区分用户的使用基准。

下面代码就是将User ID作为区分用户使用基准的情况。

```
import com.nhnent.android.toast.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS)
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }
    ……
    // 在游戏里完成登录处理
    ……
    // 把User ID作为区分用户的基准时，注册User ID的函数。
    GameAnalytics.setUserId(“user_id”, true);
    ……
}
```
    
将初始化函数的最后因子（use logging userid flag）设为true时，必须要先调用setLoggingUserId后，再注册UserID。把Flag值设为true之后，如果不调用setLoggingUserId，会致使以后调用的所有API以失败（E_LOGGING_USER_ID_EMPTY）返回。

使用推广或活动的情况下，setUserId的第二个因子就是true，否则就是false。

当调用完initializeSDK之后，因成功登录游戏而获得了可在游戏中使用的userID后，方可调用setUserId函数。userID可以使用在游戏中用以区分用户的值。

有关Advertise ID的内容，请参考以下链接。
- Android : https://developer.android.com/google/play-services/id.html


## 会话跟踪

为了跟踪DAU(Daily Active User)和游戏滞留时间而关联的项目。

开始/结束App、移到后台（Background）/前台（Foreground）时，可以调用并测量与该动作相符的API。 

初次运行App（initializeSDK之后）或从后台（background）移到前台（foreground）时，通过调用traceActivation来进行会话跟踪，然后待App进入到后台时，再调用traceDeactivation来停止会话跟踪。

如果调用traceDeactivation，就可以计算出traceActivation和traceDeactivation之间的时间，以此来测定游戏时间，并且SDK内部运行的程序，也将在traceDeactivation命令中被中止。 

移到后台/前台时，如果不调用上述函数，就无法测出准确的游戏时间，因此必须要调用此API。

DAU通常去除一日之内重复调用traceActivation的用户数（以Advertise ID或User ID为基准）后进行统计。

```
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onResume()
  {
    // 通知服务器已切换到前台状态
    GameAnalytics.traceActivation();
  }

  @Override
  protected void onPause()
  {
    // 通知服务器已切换到后台状态
    GameAnalytics.traceDeactivation();
  }
}
```


## 行为跟踪

可以跟踪用户对In-App Purchase、获得/使用虚拟货币、升级和好友数变更等行为。

### In-App Purchase

发生In-App Purchase之后，才能调用tracePurchase来传送购买信息。

Currency将使用在ISO-4217(http://en.wikipedia.org/wiki/ISO_4217)中自定义的代码。

例如，购买$0.99钻石时，将按如下步骤进行操作：

（这里的“GEM_10”是指游戏中自定义的道具代码，而Unit Cost是指该道具的单位价格，Payment是指用户实际发生的费用，Level应输入已购买用户的级别。）

```
GameAnalytics.tracePurchase("GEM_10", 0.99f, 0.99f, "USD", 10);
```


### 虚拟货币的获得和使用

在游戏中获得并使用虚拟货币时，才可以调用此选项，且可以跟踪一次和二次虚拟货币数量的变化。一般来说，一次虚拟货币是指通过In-App Purchase购买的虚拟货币（ex.钻石、红钻等）；二次虚拟货币是指使用一次虚拟货币购买的虚拟货币（ex.樱桃、爱心等）。

通过IAP购买10颗钻石时，将按如下步骤进行操作： 

（“CODE_IAP”是指游戏中自定义的代码。如一次虚拟货币时，Type为0，而二次虚拟货币是1）

GameAnalytics.traceMoneyAcquisition("CODE_IAP", "0", 10, 10);

使用10颗钻石购买100个樱桃时，将按如下步骤进行操作：

```
// 使用一次虚拟货币
GameAnalytics.traceMoneyConsumption("CODE_USE_GEM", "0", 10, 10);

// 2 获得二次虚拟货币
GameAnalytics.traceMoneyAcquisition("CODE_BUY_CHERRY", "1", 100, 10);
```

使用一次虚拟货币购买二次虚拟货币时，将会出现‘一次虚拟货币减少’->‘二次虚拟货币增加’的情况。但是为了购买二次货币而使用一次虚拟货币时，如果不想判定为是额外支付，也可以单传送‘获得二次虚拟货币’的日志（log）。

### 升级

用户级别出现变更时，将调用traceLevelUp。需要注意的是大部分的行为跟踪API，为了跟踪到各级别的行为，需要同时接收用户的级别。 

当用户级别变为10时，将按如下步骤进行调用，这时该用户的级别必须要提升，若降低，则无法测出准确的数据。

例如，像《糖果传奇》（Candy Crush Sage）一样用关卡表示级别的游戏中，只需要在最初进入该关卡时保留升级Log即可，如果返回到以前关卡进行游戏时，则无需保留升级log。

并且向其他API传送的级别值也应该使用用户的最高关卡值，而不是当前进行的关卡值。

```
GameAnalytics.traceLevelUp(10);
```


### 好友

表示注册用户的好友数。通常运行APP之后，待好友信息加载完成时，即可调用。

```
GameAnalytics.traceFriendCount(100);
```


# 选择关联的接口

本内容主要讲述在游戏中除了通过基本接口所提供的基本指标以外，还有追加测量的指标和在Analytics应用中所提供的活动功能的使用方法。

追加关联的项目如下：

* 活动（Campaign）连接 : setCampaignListener, (show/hide)Campaign
* 收集自定义事件（Custom Event） : traceEvent
* 测量所需时间 : traceStartSpeed, traceEndSpeed


## 活动（Campaign）关联

### 事先做好活动关联的准备
有关活动关联及执行内容，将另附指南。
请参考Toast Analytics中“活动执行”菜单里的“页面指南” 。
http://analytics.toast.com/promotion/share/document/4.2_Campaign_run.pdf

### 联动推送
在Analytics SDK中，为了举行活动需要启用GCM服务，而为了使用GCM，需要在Analytics的管理员页面中注册项目序号（Project Number）和API密钥（API Key），此外使用SDK还需要注册SenderID。

有关GCM的详细内容，请参考Google提供的“Google Cloud Message”文档。

http://developer.android.com/google/gcm/gs.html 

在Analytics的管理员页面中注册信息的方法，请参考“Getting Started”文档中的“推送设置”选项。

SDK中的SenderID可以通过“setGcmSenderId”API进行注册。

```
import com.nhnent.android.toast.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, false);

    if(result != GameAnalytics.S_SUCCESS)
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }
    GameAnalytics.setGcmSenderId(“123456789012”);
    ……
```

为了使用GCM，必须在AndroidManifest.xml文档中追加注册权限（permission）和接收器（receiver）。

需要追加的permission如下：（在这里需要将“APP.PACKAGE.NAME”变更为用户的PACKAGE名称。）

```
<!-- 设置gcm推送权限 -->
<uses-permission android:name="android.permission.GET_ACCOUNTS" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
<uses-permission android:name="android.permission.VIBRATE" />
<permission
          android:name="APP.PACKAGE.NAME.permission.C2D_MESSAGE"
          android:protectionLevel="signature" />
<uses-permission android:name="APP.PACKAGE.NAME.permission.C2D_MESSAGE" />
    
需要追加注册的接收器如下：（“APP.PACKAGE.NAME”同样需要变更为用户的PACKAGE名称。）
<manifest>
  ……
  <application>
    ……
    <!-- 设置gcm receiver -->
    <receiver 
        android:name="com.toast.android.analytics.gcm.GcmBroadcastReceiver"
        android:permission="com.google.android.c2dm.permission.SEND" >
            <intent-filter android:priority=”1”>
            <action android:name="com.google.android.c2dm.intent.RECEIVE" />
            <category android:name="APP.PACKAGE.NAME" />
            </intent-filter>
    </receiver>
    <service android:name="com.toast.android.analytics.gcm.GcmIntentService" />
    …… 
    </application>
</manifest>
```

如果从服务器中接收到了推送（GCM）消息，Analytics SDK就会在Notification Bar中显示通知，点击此通知时就可以运行此应用程序了。这时若不进行任何的设置，就会弹出该APP的Main Activity，如果想执行其他Activity，就需要通过“setPushIntent”函数指定此项内容。
.

```
import com.nhnent.android.toast.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, false);

    if(result != GameAnalytics.S_SUCCESS)
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }

    GameAnalytics.setGcmSenderId(“123456789012”);
    ……

    Intent intent = new Intent(getApplicationContext(), GCMActivity.class);
    GameAnalytics.setPushIntent(intent);
    ……
} 
```

需要补充的是，AndroidManifest.xml中的Activity的launchMode设置为singeTop、singleTask、singleInstance时，无需制作新的Activity，而是继续使用原来的Activity即可。

这时，为了能够准确接收含有推送消息的Intent，在该Activity中需要明确重写（Override）“onNewIntent”。

```
public class NEAFlatSampleActivity extends Activity {
    
  @Override
  protected void onNewIntent(Intent intent)
  {
    super.onNewIntent(intent);
    setIntent(intent);
  }
}
```


如果不想使用SDK提供的GCM推送接收器（Push Receiver），而是用户想亲自创建时，将清单（Manifest）文件的设置进行如下更改。

此外接收并处理GCM推送逻辑（Receiver、Service、Notification），也需要用户亲自创建。

```
<manifest>
  ……
  <application>
    ……
    <!-- 设置gcm receiver -->
    <receiver
      android:name="com.toast.android.analytics.gcm.GcmBroadcastReceiver"
      android:permission="com.google.android.c2dm.permission.SEND" >
        <intent-filter android:priority=”1”>
          <action android:name="com.google.android.c2dm.intent.RECEIVE" />
          <category android:name="APP.PACKAGE.NAME" />
        </intent-filter>
    </receiver>
    <service android:name="com.toast.android.analytics.gcm.GcmIntentService" />
    ……

    <!-- 设置与gcm push相关的用户自定义内容 -->
    <receiver 
      android:name=".GcmBroadcastReceiver"
      android:permission="com.google.android.c2dm.permission.SEND" >
      <intent-filter>
        <action android:name="com.google.android.c2dm.intent.RECEIVE" />
        <category android:name="com.example.aflatgametest" />
      </intent-filter>
    </receiver>
    <service android:name=".GcmIntentService" />

    ……
    </application>
</manifest>
```
    
如上图所示，为SDK而设置的接收器、服务下面，需要新增用户自定义设置选项。

推送有效载荷（payload）时，”cid” field不能在用户自定义的推送中使用。”cid” field作为SDK提供的内部使用标签，主要用于传送活动信息。

### 活动监听器（ Listener ）的创建及注册

SDK定期与活动服务器连接后，将获取与活动及奖励相关的信息。如果当前用户有要进行的活动或获得的奖励信息时，将通过活动监听器（Listener）发送通知。

另外，为了获得活动信息，需要创建活动监听器（Listener）。

```
public interface CampaignListener {
    void OnCampaignVisibilityChanged(string adspaceName, bool show);
    void OnCampaignLoadSuccess(string adspaceName);
    void OnCampaignLoadFail(string adspaceName, int errorCode, string errorMessage);
    void OnMissionComplete( missionList);
    void OnCampaignClick(string callbackInfo);
    void OnPromotionVisibilityChanged(bool show)
}
```


出现如下情况时，可以调用下列回调函数（Callback）：

* OnCampaignVisibilityChanged：调用showCampaign、hideCampaign之后，当出现或消失与活动相关的弹窗和横幅时，就会被调用。
* OnMissionComplete：用户进行活动/推广（Promotion）的同时，完成了指定任务而需要发送奖励信息时，就会被调用，并借助在此获得的信息，通过游戏服务器向用户发放奖励。与活动奖励相关的进程，请参考“活动应用指南”。
* OnCampaignLoadSuccess, OnCampaignLoadFail：它将通知在服务器中获取到的活动信息的Parsing结果。在游戏里无需特殊处理该回调函数（Callback），它只是为了确认log而提供的回调函数罢了。
* OnCampaignClick : 是链接选项选择Deeplink的话，即为传递登录字符串的CALLBACK。 参考所接收的字符串在游戏中对所希望进行的动作进行处理。（预计事后公布）
* OnPromotionVisibilityChanged：在使用推广的情况下，当开启或关闭推广视图（Promotion View）时，就会被调用。

创建的活动监听器，将通过setCampaignListener进行注册。


```
function setListener() {
  ……
  GameAnalytics.setCampaignListener(new MyCampaignListener() {
    public void OnCampaignVisibilityChanged(string adspaceName, bool show) {
      ……
    }

    public void OnCampaignLoadSuccess(string adspaceName) {
      // for Debugging
    }

    public void OnCampaignLoadFail(string adspaceName, int errorCode, string errorMessage) {
      // for Debugging
    }

    public void OnMissionComplete(List<string> missionList) {
      // 在missionList String中，key/value的信息将以分割符‘|’显示。
      // 通过游戏服务器在推广服务器（promotion server）中验证其值后，向用户
      // 发放奖励。
    }
    
    public void OnCampaignClick(string callbackInfo) {
      // 是链接选项选择Deeplink的话，即为传递登录字符串的CALLBACK。 
      // 参考所接收的字符串在游戏中对所希望进行的动作进行处理。（预计事后公布）
    }
    
    public void OnPromotionVisibilityChanged(bool show) {
      // 当推广视图被开启时，show将转为true。
      // 将show设为true时，可以降低游戏渲染（Rendering）的功能。
      // 相反，show设为false时，可以使游戏渲染功能恢复至原来的状态。
    }
  });
}
```

### 活动的展示（Show）/隐藏（Hide）
是指当前用户若有正在进行的活动时，向该用户展示在Analytics网站注册的活动弹窗/横幅的同时，将已展示的弹窗/横幅隐藏的一种方法（Method）。参数adspaceName，可以使用在Analytics网站注册时使用的adspace名称。这里的Adspace是指游戏内展示弹窗/横幅的特定位置。

如果活动中不使用该adspace，showCampaign() Method将不会启动，所以先确定好游戏内可出现活动弹窗/横幅的几个地点后，以不同的adspaceName调用函数的话，可以不经过游戏客户端的修改，游戏运营人员也可以通过在Analytics网站自行注册活动这一步骤，将弹窗/横幅展示给用户。注册Adspace的方法，请参考“活动测试指南”。

```
public static int showCampaign(String adspaceName, Activity activity)
public static int showCampaign(String adspaceName, Activity activity, int animation, int lifeTime) 
public static int hideCampaign(String adspaceName)
public static int hideCampaign(String adspaceName, int animation)
```

## 自定义事件（Custom Event）的使用

需要给各游戏进行定义和分析特定事件时使用。

例如，使用Fever Time Item时，将按如下步骤进行操作。使用的所有代码，在游戏中自定义后使用。下面示例是在特定关卡中，为了跟踪道具变动内容而自定义的代码。

```
GameAnalytics.traceEvent("ITEM", "ITEM_USE", "FEVER", "STAGE_10", 1, 10);
```

也可以在特定级别中跟踪与BOSS对战的结果时使用。

```
GameAnalytics.traceEvent("STAGE", "STAGE_BOSS_VICTORY", "DRAGON_VALLEY", "BOSS_MOB", 1, 10);
```

除此之外，还具有可跟踪游戏内特殊事件的多种用途。

在traceEvent中使用的String Type参数（event type, event code, param1, param2），每个最多可用50字节，而且在event下面有可能发生的param1最多为300个，在param1下面有可能发生的param2最多为200个。

详细内容请参考Toast Analytics网站的指南。（点击Custom event页面右上角的“页面指南”，即可下载）


## 联动推广（Promotion）

在游戏内与其他游戏进行联动推广时使用。

### 事先做好联动推广的准备
有关联动及执行推广的内容，将另附指南。

### 添加推广按键
在Analytics设置页面中，如果注册完推广信息后，再注册按键图片（image），就可以在SDK初始化时，将下载的按键保存在设备（Device）中。

在游戏中需要使用按键图片在适当的位置生成按键。

生成按键之前，需要先确认一下是否可以进行推广。当管理者在Analytics网站中设置为不使用推广，或者出现按键图片下载失败或正在进行推广维护或故障时，就无法进行推广了，所以画面中不应该显示按键。通过“isPromotionAvailable()”可以确认到能否进行推广。如果可以进行推广，使用“getPromotionButtonImagePath()&rdqou; 函数确认按键图片的路径后，在游戏内适当的位置生成按键即可。（按键图片要以PNG形式保存。）

（如果不想使用在Analytics设置中注册的图片，那么可以使用包含在游戏发布包中的图片生成按键。但是，这时也需要先确认一下能否进行推广-isPromotionAvailable-，然后再生成按键。）

```
if (GameAnalytics.isPromotionAvailable() == true) {
    String buttonImagePath = GameAnalytics.getPromotionButtonImagePath();
    Drawable d = new BitmapDrawable(activity.getResources(), buttonImagePath);
    ……
} else {
    Debug.Log ("Hide Toast Promotion Button");
}
```

### 推广执行
点击推广按键的同时调用“launchPromotionPage()”后，执行推广即可。

```
private void touchPromotionButton() {
    ……
    GameAnalytics.launchPromotionPage();
    ……
}
```

“launchPromotionPage()”에서는 내부적으로 WebView를 사용하여 프로모션 컨텐츠를 제공합니다. 이 기능을 사용하기 위해서는 AndroidManifet.xml 설정에 해당 Activity를 추가해야 합니다.

使用android:screenOrientation设置横/竖屏的固定。 (http://developer.android.com/guide/topics/manifest/activity-element.html#screen)

```
<activity
    android:configChanges="keyboard|keyboardHidden|orientation|
        screenLayout|uiMode|screenSize|smallestScreenSize"
    android:name="com.toast.android.analytics.PromotionActivity" />
```

并且安装/运行APP时，为了测试其广告效果，需要先注册Install Receiver。

Install Receiver是指通过推广安装APP时（仅适用于Google Play），为了能够测出其效果所需要的程序；Execution Receiver是指在已安装APP的情况下，通过推广测试其执行效果时所需要的程序。详细内容请参照“2.2.2. AndroidManifest设置”。


### 奖励
向用户展示推广页面的同时，即发放奖励。并且通过推广安装APP或已完成指定任务时，也会发放奖励。

有关奖励信息，将通过“活动监听器”的“onMissionComplete”传送给用户。

奖励流程，请参考“应用及运营推广指南”。


## 测量所需时间

可以测量特定区间所需时间。例如，不管是测量新手教程还是转换场景（Scene）时所需的时间，只要是需要测量时间的任何区间，都可以使用它。

需要测量介绍场景（Intro Scene）的加载时间时，按如下步骤操作即可。“INTRO_LOADING”是指游戏内对特定的区间自定义的值。

```
private void onStart() {
    GameAnalytics.traceStartSpeed("INTRO_LOADING");
}

private void onLoadCompleted() {
    GameAnalytics.traceEndSpeed("INTRO_LOADING");
}
```


# SDK设置

## DEBUG模式的激活
在开发过程中，为了确认SDK日志（log），可以设置日志的输出与否。

该函数在initializeSDK的之前/之后，都可以进行调用，基本值为setDebugMode(false)。

Log tags是以“Analytics:”开始的，如果在Eclipse中将logcat过滤器指定为“Analytics”，就可以确认在SDK发生的日志。

```
private void Start () {
     ……
     GameAnalytics.setDebugMode(true);
     ……

     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", false);

     if (result != 0 ) {
        // SDK初始化失败
     }
     ……
}
```

激活DEBUG模式后，可以确认传送日志的内容。传送完日志后，再确认其回复就可确定日志是否传送无误。出现如下日志字符串，就说明收集到的数据已正常传送到了服务器上。（***是根据情况会出现不同的值）

```
Android : server response (***) : 200 OK
```


## 设备（Device）信息的确认
可以确认在SDK获取到的设备信息。

当前可以确认到设备账号、推送令牌和活动用户账号的值，这些都是测试活动连接时所需的值。详细内容请参考“活动连接指南”。

下面是为了确认设备信息而使用的密钥值。
- public static final String DEVICE_INFO_DEVICEID = “deviceId”;
- public static final String DEVICE_INFO_TOKEN = “token”;
- public static final String DEVICE_INFO_CAMPAIGN_USERID = ”campaignUserId”;

```
private void printDeviceInfo() {
     String deviceID = GameAnalytics.getDeviceInfo(DEVICE_INFO_DEVICEID);
     String pushToken = GameAnalytics.getDeviceInfo(DEVICE_INFO_TOKEN);
     String campaignUserID = GameAnalytics.getDeviceInfo(DEVICE_INFO_CAMPAIGN_USERID);
     ……
}
```

## SDK版本的确认
SDK版本可以通过&lduo;getVersion()”函数进行确认。

```
public static String getVersion()
```
