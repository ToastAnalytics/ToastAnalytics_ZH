#Overview
Analytics中的活动是指内部(In House)活动。在APP内通过弹窗或横幅向用户显示事件（任务），而且当用户进行该事件时，根据完成情况发放奖励的功能。Toast Analytics的内部In House活动功能不仅提供因活动执行而增加的用户数、销售额等成果分析指标，而且为了提高活动效率，还会找到符合活动目的的目标对象。

为了使用此项功能，需要进行如下附加操作。
######1. 为了展示活动以及处理奖励，需要在APP客户端上使用Toast Analytics SDK。
######2. 为了通知用户已完成任务，以及确认是否获得奖励，需要进行游戏服务器（或者APP服务器）与活动服务器间的通信。

## 活动术语说明
活动服务中将使用如下术语

|术语|说明|
|---|---|
|（In House）活动 |	是指在APP内通过弹窗或横幅向用户显示事件（任务），且当用户完成该任务时，还可发放奖励的Toast Analytics功能。|
|（活动）任务 |	是指为了获得活动奖励，用户需要完成的目标。|
| 自定义数据 |	是指为了完成任务，基于用户行为信息的数据。|
|（活动）奖励 |	是指用户完成任务时应发放的APP内游戏币。|

## 重要关联项目的说明
活动服务操作流程如图1。
![Project Sett](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_ZH/master/docs/Developer/images/image003.png)
[图1 服务操作流程图]

下面是关联活动时所需的重要项目的简要说明，在后面将会有详细介绍。 

###1. Toast Analytics SDK的导入
为了使用Analytics活动功能，需要把Toast Analytics SDK导入到APP里。
关于导入该软件的内容，请参考文档的后半部分，或者可参考Toast Analytics API reference文档。

###2. 活动设置
可以直接生成新活动，但是通过模板能更快捷、更有效率地生成活动。
点击Toast Analytics网站的【活动执行】菜单，可以创建新活动。与此相关的详细说明，请参考页面右上方的【页面指南】。

###3. 注册测试终端机
将活动展示给普通用户之前，为了确认活动正常展示及操作与否，需要通过测试这一步骤，并在Toast Analytics SDK获取Device ID和Device Token后，注册测试终端机即可。
可以通过Analytics网站的【APP设置键】 >【活动设置】> 【测试设备设置】，注册测试终端机。

###4. 活动测试
正常注册完测试终端机后，就可以通过Toast Analytics网站进行测试了。 
可以通过Analytics网站的【活动执行菜单】> 【活动列表】> 【测试按键】开始测试。

###5. 活动操作步骤的确认
通过测试终端机确认活动正常操作与否。
需要确认以下4个阶段的进行状态，每个阶段的详细内容，请在Toast Analytics网站右上方的页面指南中确认。
- 展示：是指使用测试终端机正常传送活动信息后，处于展示准备的状态。
- 执行：是指在测试终端机上显示横幅或弹窗后，已参加活动的状态。
- 任务：是指游戏服务器向活动服务器正常传送任务数据的状态。
- 奖励：是指活动服务器向游戏服务器正常传送奖励信息的状态。

###6. 活动展示
完成所有活动测试时，为了让外部用户连接，需要开启活动。活动开启并APP展示在指定位置时（参照活动设置>展示位置设置内容），活动将被展示出来。

###7. 任务完成及奖励的处理
用户为了完成任务而进行特定操作（例级别、等级变化等）时，游戏服务器将调用活动服务器API（check-mission）来确认任务的完成与否。
如果完成任务，活动服务器将向游戏服务器发送奖励信息，游戏服务器将根据这一信息给客户端发放奖励。

# 应用步骤（开发人员）

活动系统的操作流程如下图2。
![Project Sett](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_ZH/master/docs/Developer/images/image004.png)

[图2 系统操作流程图]

## 游戏客户端

（为了便于理解，将用Java Code进行说明。详细内容请参考各平台提供的Programming Guide。）

###1. 初始化

为了使用该活动功能，必须先调用初始化函数。

```
GameAnalytics.initializeSdk(getActivity(), appId, entId, appVer,  useLoggingUserId);
```


邀请活动信息前注册活动监听器（Listener）。
```
GameAnalytics.setCampaignListener(campaignListener); 
```

监听器（Listener）将提供下列回调函数（Callback）。
- onCampaignVisibilityChanged : 当出现或消失与活动及奖励相关的弹窗及横幅时，将被调用。
- onCampaignLoadSuccess, onCampaignLoadFail : 它将通知在活动服务器中获取到的活动信息的分析结果。在游戏中无需对此回调函数Callback进行特殊处理，它只是为了确认日志而提供的回调函数罢了。

```
private CampaignListener campaignListener = new CampaignListener() {
@Override
public void onCampaignVisibilityChanged(String adSpaceName, boolean show) { ... }
@Override
public void onCampaignLoadSuccess(String adSpaceName) { ... }
@Override
public void onCampaignLoadFail(String adSpaceName, CampaignException exception) { ... }
}; </string>
```
###2. 注册用户ID
为了进行活动及奖励的处理，必须对用户进行区分，活动将根据用户的ID区分用户，并且为了使用活动功能，必须要调用设置用户ID的函数。
这时使用的用户ID值，必须要与在游戏服务器完成任务时调用的API用户ID值相同。
用户ID必须是区分用户的唯一值，并且是50Byte以下的文字列。
``` 
GameAnalytics.setUserId(userId,true); 
```
###3. 活动展示
onCampaignLoadSuccess以后，应在展示活动的位置中调用活动展示函数。
而且在一定时间内向用户展示以后，需要调用清除函数来清除活动弹窗及横幅。
将提供下列API。
```
showCampaign(String adspaceName, Activity parent);
showCampaign(String adspaceName, Activity parent, int animation, int lifeTime);
hideCampaign(String adspaceName);
hideCampaign(String adspaceName, int animation);
```

###4. 奖励信息的处理
在活动中包含任务或奖励信息时，用户每次执行与任务相关的操作后，游戏服务器向活动服务器确认任务完成情况，如果确认任务已完成，就会把奖励信息发送到游戏客户端。该部分为游戏服务器与游戏客户端之间的规则，在游戏内自行处理即可。

###5. 联动推送
在Analytics SDK中为了举行活动需要使用GCM，而为了使用GCM，需要在Analytics管理员页面中注册Project Number和API Key，此外使用SDK还需要注册SenderID。
有关GCM的内容请参考Google提供的“Google Cloud Message”文档。 （http://developer.android.com/google/gcm/gs.html）
在Analytics管理员页面注册信息的方法，请参考“Getting Started”文档的“推送设置”内容。
SDK中的SenderID可以通过“setGcmSenderId”进行注册。
```
 import com.nhnent.android.toast.analytics.GameAnalytics;
public class TestActivty extends Activity {
@Override
protected void onCreate(Bundle savedInstanceState)
{
super.onCreate();
……
int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, false);
if(result != GameAnalytics.S_SUCCESS)
	Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
}
GameAnalytics.setGcmSenderId(“123456789012”);
……
} 
```

为了使用GCM，需要在AndroidManifest.xml文档中追加注册permission与reciever。
需要追加的permission如下。（这里的“APP.PACKAGE.NAME”需改为用户的Package名。）
```
<!--  gcm 푸쉬 권한 설정 -->
<uses-permission android:name="android.permission.GET_ACCOUNTS"></uses-permission>
<uses-permission android:name="android.permission.WAKE_LOCK"></uses-permission>
<uses-permission android:name="com.google.android.c2dm.permission.RECEIVE"></uses-permission>
<uses-permission android:name="android.permission.VIBRATE"></uses-permission>
<permission android:name="APP.PACKAGE.NAME.permission.C2D_MESSAGE" android:protectionLevel="signature"></permission>
<uses-permission android:name="APP.PACKAGE.NAME.permission.C2D_MESSAGE"></uses-permission>
```

需要追加注册的接收者（Receiver）如下。（“APP.PACKAGE.NAME”需改为用户的Package名。）
```
<manifest>
……
<application>
……
<!-- gcm 리시버 设置 --> 
<receiver android:name="com.toast.android.analytics.gcm.GcmBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND">
	<intent-filter android:priority="”1”">
	  <action android:name="com.google.android.c2dm.intent.RECEIVE"></action>
	  <category android:name="APP.PACKAGE.NAME"></category>
	</intent-filter>
</receiver>
<service android:name="com.toast.android.analytics.gcm.GcmIntentService"></service>
……        
</application>
</manifest>
```

当服务器接收推送（GCM）消息后，Analytics SDK将在通知栏（Notification Bar）标为已通知，点击此通知即可运行APP了。这时若对此未进行任何设置，那么将会显示该APP的Main Activity。当前须运行的是其他Activity，而不是Main Activity时，需要通过“setPushIntent”函数明确指定出来。
```
import com.nhnent.android.toast.analytics.GameAnalytics;
public class TestActivty extends Activity {
@Override
protected void onCreate(Bundle savedInstanceState)
{
super.onCreate();
……
int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, false);
if(result != GameAnalytics.S_SUCCESS)
	Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
}
GameAnalytics.setGcmSenderId(“123456789012”);
……
Intent intent = new Intent(getApplicationContext(), GCMActivity.class);
GameAnalytics.setPushIntent(intent);
……
} 
```

将AndroidManifest.xml里的Activity android:launchMode设置为singeTop, singleTask, singleInstance时，无需生成新的Activity，而是继续使用当前的Activity即可。
这时，为了正常接收与推送有关的意图（Intent）信息，需在相关Activity中明确重写“onNewIntent”。
```
public class NEAFlatSampleActivity extends Activity {
@Override
protected void onNewIntent(Intent intent)
{
super.onNewIntent(intent);
setIntent(intent);
}
} 
```

如果不使用SDK提供的GCM推送接收器，而是用户亲自创建时， 需要将Manifest文件的设置进行如下更改：此外，接收并处理GCM推送的逻辑（Receiver、Service、Notification），也需要用户亲自创建。
```
<manifest>
……
<application>
……
<!-- 设置gcm receiver --> 
<receiver android:name="com.toast.android.analytics.gcm.GcmBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND">
<intent-filter android:priority="”1”">
  <action android:name="com.google.android.c2dm.intent.RECEIVE"></action>
  <category android:name="APP.PACKAGE.NAME"></category>
</intent-filter>
</receiver>
<service android:name="com.toast.android.analytics.gcm.GcmIntentService"></service>
……
<!-- 设置与gcm push相关的用户自定义内容 -->
<receiver android:name=".GcmBroadcastReceiver" android:permission="com.google.android.c2dm.permission.SEND">
<intent-filter>
<action android:name="com.google.android.c2dm.intent.RECEIVE"></action>
<category android:name="com.example.aflatgametest"></category>
</intent-filter>
<receiver>
<service android:name=".GcmIntentService"></service>
……
</application>
</manifest>
```

如上图所示，在为SDK而设置的接收器、服务内容下面，需新增用户自定义设置选项。
创建推送有效载荷（payload）时，无法在用户自定义的推送中使用“cid” field。“cid” field作为SDK提供的内 部使用标签，主要为传送活动信息所用。

###6. 确认Device ID和Push Token
为了进行本菜单中的【应用操作步骤（游戏运营人员）】>【环境设置】>【活动设置】>【测试设备的设置】部分，需要测试终端设备的设备账号（Device ID）和推送令牌（Push Token）的信息。
在Toast Analytics SDK中，为了确认设备账号和推送令牌，将会给各平台提供API，且将在initializeSDK之后才可调用此API。
```
Android
public static String DEVICE_INFO_DEVICEID = "deviceId";
public static String DEVICE_INFO_TOKEN = "token";         
public static String DEVICE_INFO_CAMPAIGN_USERID = "campaignUserId";
public static String getDeviceInfo(String key)
iOS
#define DEVICE_INFO_DEVICEID (@"deviceId")
#define DEVICE_INFO_TOKEN (@"token")
#define DEVICE_INFO_CAMPAIGN_USERID (@"campaignUserId")
+(NSString*)deviceInfoWithKey:(NSString*)key
Unity
public const string DEVICE_INFO_DEVICEID = "deviceId";
public const string DEVICE_INFO_TOKEN = "token";         
public const string DEVICE_INFO_CAMPAIGN_USERID = "campaignUserId";
public static string getDeviceInfo(string key)
Cocos2d-x
#define DEVICE_INFO_DEVICEID_STR ("deviceId")
#define DEVICE_INFO_TOKEN_STR ("token")
#define DEVICE_INFO_CAMPAIGN_USERID_STR ("campaignUserId")
std::string getDeviceInfo(std::string key) 
```

下面是在Android中输出Device ID和Push Token的代码。
```
// 获取Device ID。
String deviceId = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_DEVICEID);
// 获取Push Token。
String pushToken = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_TOKEN);
// 将获取到的Device ID和Push Token，输出到Logcat控制台。
Log.d(“Sample”, “Device ID : “ + deviceId);
Log.d(“Sample”, “Push Token : “ + pushToken); 
```

为了确认log，Android要使用Logcat，而iOS要使用iPhone Configurator。
![Project Sett](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_ZH/master/docs/Developer/images/image005.png)
[图3 输出到控制台log的Device ID和Push Token]

Device ID和Push Token的输出代码，仅限测试时使用，而在对外公开的版本中，将此项删除即可。

# 游戏服务器

###1. 游戏服务器认证
对活动服务器的访问限制政策，在ACL中将更改为其他方式。
目前对外部流入的情况，没有通过ACL加以限制。
今后，明确了与认证相关的政策后，需要进行追加业务的操作。

###2. 奖励处理方案
与活动相关的游戏服务器的主要工作就是对奖励的处理。
出现如下情况时，游戏服务器使用活动服务器调用check-mission API之后，再对任务完成情况进行确认。
- 在进行活动时，与任务设置有关的因素（在游戏中对Level、Ranking、游戏运行次数等已指定的值）出现变化的情况

在活动服务器中调用check-mission API时，如果有奖励就会获得奖励代码，然后再把发放的奖励向游戏客户端发送即可，该处理需在游戏内完成。
（通过回复数据的rewardList field发送奖励信息，且仅发送一次。需要注意的是，即使没有奖励，也会通过 rewardList field发送信息，只是传送空白值。）

游戏服务器调用的任务完成通知API的格式如下：

###3. 请求示例
```
Host: https://api-campaign-analytics.cloud.toast.com
POST /campaign/v1/server/check-mission
Content-Type: application/json
{
"header":
{
"transactionId" : 92348729384729,
},
"userId" : "23948234",
"appId" : "13",
"missionKey" : "LEVEL",
"missionValue" : 10
} 
```

###4. 请求参数（必需要有数据域。）

|姓名|资料型|说明|
|---|---|---|
|transactionId|	int64|	为了跟踪请求事宜，在Logging时使用，但不是必需值。在这里输入的值，也同样会在回复数据的transactionId field中完成设置后返回。|
|userId|	string|	游戏中提供的用户唯一账号（unique ID）|
|appId|	string| 注册APP时获得的APP账号
输入Analytics网站的【APP设置】>【Appkey】值即可。|
|missionKey|	表示定义特定行为的密钥值或通过onMissionComplete(SDK)接收到的值。进入Analytics网站的【APP设置】>【活动设置】>【任务及奖励道具的设置】后，所注册的任务密钥值 |
|missionValue|	int64|	表示missionKey值 |

###5. 回复示例
```
HTTP/1.1 200 OK
{
"header" :
{
"transactionId" : 92348729384729,
"isSuccessful" : "false",
"resultcode" : 9001,
"resultMessages" : ["Invalid input parameter.", "..."],
"serviceCode" : 10
},
"rewardList" : [
{
"campaignId" : 7,
"promoDateBegin" : "2014-10-10 00:00:00",
"promoDateEnd" : "2014-10-11 00:00:00",
"rewardDateBegin" : "2014-10-10 00:00:00",
"rewardDateEnd" : "2014-10-12 00:00:00",
"rewardCode" : "gem",
"rewardValue" : 100
},
...
]
}
```

###6. 回复数据

|姓名|资料型|说明|
|---|---|---|
|transactionId	|int64|	使用请求时接收到的transactionId来设置。|
|isSuccessful	|string|	设置执行成功与否。（成功："true"、失败："false"）|
|resultCode	|int|	编写返回代码。（成功时为0）|
|resultMessages	|vector<string>|	编写复数数组的返回信息。|
|serviceCode	|int|	表示服务代码 |
|campaignId	|int|	表示有奖励的活动账号 |
|promoDateBegin	|string|	表示活动开始时间（以UTC+0为基准）|
|promoDateEnd	|string|	表示活动结束时间（以UTC+0为基准）|
|rewardDateBegin	|string|	表示奖励开始时间（以UTC+0为基准）|
|rewardDateEnd	|string|	表示奖励结束时间（以UTC+0为基准）|
|rewardCode	|string|	表示奖励代码 |
|rewardValue	|int|	表示奖励值|
